---
layout: article
title: ROS入门
---

#### 前言

***

菜鸟为更加深入理解和学习ros，决定写博客来促进学习。

***

# ROS之Topic

## 1，Topic概念

ROS的节点（node）通信非常重要，节点间的通讯方式之一就是Topic。

话题就是ROS中一个**数据传输的有名字的通道**。当一个节点想要分享信息时，它就会发布(publish)消息到对应的一个或者多个话题；当一个节点想要接收信息时，它就会订阅(subscribe)它所需要的一个或者多个话题。 ROS节点管理器负责确保发布节点和订阅节点能找到对方；而且消息是直接地从发布节点传递到订阅节点，中间并不经过节点管理器转交。

## 2，Topic通信机制

![图解话题通信机制]({{ site.url }}/assets/images/话题通信机制.jpg)

说明：发布者将消息发布到Topic(话题)，订阅者订阅话题就会接收到消息，通俗的理解就是，我订阅了B站上的UP主，UP主发视频，我就能接收到视频。

特点：

Topic通信是**多对多的异步通信**方式:

1,Topic Publisher调用publish()方法发布消息，发送完立即返回，不用等待反馈；Subscriber通过回调函数的方式来处理消息。

2,对于同一Topic，系统中可以同时存在多个Publisher和多个Subscriber；

3,另外，Publisher并不知道哪个节点会接收消息，而Subscriber也并不知道接收的消息来自哪个节点，节点之间是松耦合的，这也是ROS最关键的设计特性之一。

4,**节点既可以是发布者，同时也可以是订阅者**

## 3，Topic命令行工具

ROS提供了一些命令行工具帮助我们查看Topic的信息：

```c
rostopic list //打印出当前正在运行的话题
rostopic info <topic_name> //查看指定Topic的信息
rostopic echo <topic_name> //打印指定Topic的内容
//更多ROS Topic的命令行工具可通过在终端中输入 rostopic -h 查看
```

## 4，Topic实现

### 代码

参考：[ROS_Topic_Wiki]([cn/ROS/Tutorials/WritingPublisherSubscriber(c++) - ROS Wiki](http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber(c%2B%2B)))

发布者：

```c++
#include "ros/ros.h"
//ros/ros.h是一个很便利的include，它包括了使用ROS系统中最常见的公共部分所需的全部头文件。
#include "std_msgs/String.h"
//它引用了位于std_msgs包里的std_msgs/String消息。这是从std_msgs包里的String.msg文件中自动生成的头文件。
#include <sstream>//用于后面定义字符串SS，并将其输出到屏幕（可以不用）
int main(int argc, char **argv)
{
  ros::init(argc, argv, "talker");
  //初始化ROS。这使得ROS可以通过命令行进行名称重映射,这也是我们给节点指定名称的地方。节点名在运行的系统中必须是唯一的。注意：名称必须是基本名称，例如不能包含任何斜杠/。
  ros::NodeHandle n;
  //为这个进程的节点创建句柄。创建的第一个NodeHandle实际上将执行节点的初始化，而最后一个被销毁的NodeHandle将清除节点所使用的任何资源。
  ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter", 1000);
  //告诉主节点我们将要在chatter话题上发布一个类型为std_msgs/String的消息。这会让主节点告诉任何正在监听chatter的节点，我们将在这一话题上发布数据。第二个参数是发布队列的大小。在本例中，如果我们发布得太快，它将最多缓存1000条消息，不然就会丢弃旧消息。
  //ros::Publisher chatter_pub相当于定义了一个发布者chatter_pub，NodeHandle::advertise()返回一个ros::P ublisher对象，它有2个目的：其一，它包含一个publish()方法，可以将消息发布到创建它的话题上;其二，当超出范围时，它会自动取消这一宣告操作。
  ros::Rate loop_rate(10);//ros::rate对象能让你指定循环的频率。这里是10Hz
  int count = 0;
  while (ros::ok())
  //默认情况下，roscpp将安装一个SIGINT处理程序，它能够处理Ctrl+C操作，让ros::ok()返回false。
  //ros::ok()在以下情况会返回false：
  //收到SIGINT信号（Ctrl+C）
  //被另一个同名的节点踢出了网络
  //ros::shutdown()被程序的另一部分调用
  //所有的ros::NodeHandles都已被销毁
  //一旦ros::ok()返回false, 所有的ROS调用都会失败。
  {
    std_msgs::String msg;//实例化一个消息对象
    std::stringstream ss;
    ss << "hello world " << count;
    msg.data = ss.str();
    ROS_INFO("%s", msg.data.c_str());//将发布的消息显示到屏幕
    chatter_pub.publish(msg)//广播消息
    ros::spinOnce();
      //此处调用ros::spinOnce()对于这个简单程序来说没啥必要，因为我们没有接收任何回调。然而，如果要在这个程序中添加订阅，但此处没有ros::spinOnce()的话，回调函数将永远不会被调用。所以还是加上吧。
    loop_rate.sleep();//使用ros::Rate在剩下的时间内睡眠，以让我们达到10Hz的发布速率。
    ++count;
  }
  return 0;
}
```

订阅者：

```c++
#include "ros/ros.h"
#include "std_msgs/String.h"//注意：订阅者也要包含消息的头文件

void chatterCallback(const std_msgs::String::ConstPtr& msg)//回调函数
{
  ROS_INFO("I heard: [%s]", msg->data.c_str());
}
//当有新消息到达chatter话题时它就会被调用。该消息是用boost shared_ptr智能指针传递的，这意味着你可以根据需要存储它，即不用担心它在下面被删除，又不必复制底层（underlying）数据。

int main(int argc, char **argv)
{

  ros::init(argc, argv, "listener");
  ros::NodeHandle n;

  ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);
  //通过主节点订阅chatter话题。每当有新消息到达时，ROS将调用chatterCallback()函数。第二个参数是队列大小，以防我们处理消息的速度不够快。在本例中，如果队列达到1000条，再有新消息到达时旧消息会被丢弃。
  //NodeHandle::subscribe()返回一个ros::Subscriber对象，你必须保持它，除非想取消订阅。当Subscriber对象被析构，它将自动从chatter话题取消订阅。
  ros::spin();
  //ros::spin()启动了一个自循环，它会尽可能快地调用消息回调函数。
  return 0;
}
```

### 自定义消息

以上用的是标准的消息结构，同时也可以使用自定义消息(Message)结构：

1，在功能包下建立msg文件夹，在msg文件夹下新建.msg结尾的文件，在里面定义消息的类型

2，msg文件遵循一定规范的，每一行表示一种数据。前面是类型，后面是名称。

3，ros不只是提供了`int64`和`string`两种基本类型供我们描述，其实还有很多：

|  msg类型   |   C++对应类型   |  Python对应类型  |
| :--------: | :-------------: | :--------------: |
|   `bool`   |    `uint8_t`    |      `bool`      |
|   `int8`   |    `int8_t`     |      `int`       |
|  `int16`   |    `int16_t`    |      `int`       |
|  `int32`   |    `int32_t`    |      `int`       |
|  `int64`   |    `int64_t`    |  `int`，`long`   |
|  `uint8`   |    `uint8_t`    |      `int`       |
|  `uint16`  |   `uint16_t`    |      `int`       |
|  `uint32`  |   `uint32_t`    |      `int`       |
|  `uint64`  |   `uint64_t`    |  `int`，`long`   |
| `float32`  |     `float`     |     `float`      |
| `float64`  |     `float`     |     `float`      |
|  `string`  |  `std:string`   |  `str`，`bytes`  |
|   `time`   |   `ros:Time`    |   `rospy.Time`   |
| `duration` | `ros::Duration` | `rospy.Duration` |

4，修改功能包下的package.xml文件：

添加：

```
  <build_depend>message_generation</build_depend>
  <exec_depend>message_runtime</exec_depend>
```

在构建时，其实只需要`message_generation`，而在运行时，我们只需要`message_runtime`。

5，修改CMakeLists.txt文件：

为已经存在里面的`find_package`调用添加`message_generation`依赖项，这样就能生成消息了。直接将`message_generation`添加到`COMPONENTS`列表中即可，如下所示：

```
# 不要直接复制这一大段，只需将message_generation加在括号闭合前即可
find_package(catkin REQUIRED COMPONENTS
   roscpp
   rospy
   std_msgs
   message_generation
)
```

还要确保导出消息的运行时依赖关系：

```
catkin_package(
  ...
  CATKIN_DEPENDS message_runtime ...
  ...)
```

找到如下代码块：

```
# add_message_files(
#   FILES
#   Message1.msg
#   Message2.msg
# )
```



删除`#`符号来取消注释，然后将`Message*.msg`替换为你的.msg文件名，就像下边这样：



```
add_message_files(
  FILES
  Num.msg
)
```

现在必须确保`generate_messages()`函数被调用：

**在ROS Hydro及更新版本中，**你需要取消下面几行的注释：

```
# generate_messages(
#   DEPENDENCIES
#   std_msgs
# )
修改为：
 generate_messages(
   DEPENDENCIES
   std_msgs
 )
```

6，编译

在代码中包含自定义消息头文件即可使用

```c++
//方式：
#include "功能包名/自定义消息名.h"
```

